What happens when you initialize a respository? why you need to do it?

When initializing it will create the .git file and create the repositorty , which stores the meta data
.git file needed to be created to store meta data 
When I create a repository, Git creates a directory vhere it will keep track
of all the versions that I save.  Creating the repository also lets Git know
that I want all the files in this directory to be tracked together, but
separately from files in different directories.  If I didn't create the
repository, Git could create the directory to save the versions in
automatically, but it wouldn't know which files I wanted to track together
and which I wanted to track separately.

How is the staging area different from the working directory and the repository?
What value do you think it offers?

git commit will allow us to commit all the files in the working directory to the empty repository we made 
using git init above. but git allow us to use a staging area to add only the files
we want to commit by command git add.Staging area is in between directory and the respository. 
Then from staging area we can commit all the files we want to the repository

The staging area is an intermediate area where I can add changes before
committing them to the repository.  This allows me to add changes to the
staging area one-by-one, then commit them all at once, which makes it easier
to specify what changes should go into each commit.  That makes the commits
more valuable, since the commit history is easier to navigate when I create
one commit per logical change.


How can you use the staging area to make sure you have one commit per logical
change?

If I've made more than one logical change since committing, I can add all
the changes affected by the first logical change to the staging area, then
commit those without committing the others.


What are some situations when branches would be helpful in keeping your history
organized? How would branches help?

I like to use master as a stable version of my code and create a new branch
when I'm planning on working on something experimental, or that will be
non-stable for a little while.  That makes it easier to switch back to the
stable version whenever I need to.  This is particularly helpful when I am
working with other developers, since the other developers can trust that
master is stable.  They can always check out my branch if they are
interested in my experimental changes.

When I'm working on my own, and I make a change that I do not expect to
break anything, I frequently don't bother to make another branch.  However,
making a new branch in Git is so fast and easy that there is really no bad
time to make a branch, unless I make so many that I cannot keep track of
them all.



How do the diagrams help you visualize the branch structure?
The diagrams show what the parent of each commit is.  When there are
multiple branches, I can use the diagrams to easily see what changes will be
part of each branch.  They also let me easily see what commit each branch
refers to.

What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?

The result of merging two branches together is a combined commit with all
the changes from both branches.  We represent the merge in the diagram as
having two parents - the two commits that it combined.  For non-merge
commits, the parent of the commit is the state of the files before that
commit was made.  For merge commits, there was no one state of the files
before the commit was made, since the merge commit combines two commits
together, so it makes sense for the merge commit to have two parents.

What are the pros and cons of Git's automatic merging vs. always doing merges
manually?